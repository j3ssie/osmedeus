package repository

import (
	"context"

	"github.com/j3ssie/osmedeus/v5/internal/database"
	"github.com/uptrace/bun"
)

// VulnerabilityRepository handles vulnerability database operations
type VulnerabilityRepository struct {
	db *bun.DB
}

// NewVulnerabilityRepository creates a new vulnerability repository
func NewVulnerabilityRepository(db *bun.DB) *VulnerabilityRepository {
	return &VulnerabilityRepository{db: db}
}

// VulnerabilityQuery represents query parameters for vulnerability search
type VulnerabilityQuery struct {
	Workspace  string
	Severity   string
	Confidence string
	AssetType  string
	AssetValue string
	VulnTitle  string
	Page       int
	PerPage    int
}

// Create creates a new vulnerability
func (r *VulnerabilityRepository) Create(ctx context.Context, vuln *database.Vulnerability) error {
	_, err := r.db.NewInsert().Model(vuln).Exec(ctx)
	return err
}

// GetByID retrieves a vulnerability by ID
func (r *VulnerabilityRepository) GetByID(ctx context.Context, id int64) (*database.Vulnerability, error) {
	vuln := new(database.Vulnerability)
	err := r.db.NewSelect().
		Model(vuln).
		Where("id = ?", id).
		Scan(ctx)
	if err != nil {
		return nil, err
	}
	return vuln, nil
}

// Update updates an existing vulnerability
func (r *VulnerabilityRepository) Update(ctx context.Context, vuln *database.Vulnerability) error {
	_, err := r.db.NewUpdate().
		Model(vuln).
		WherePK().
		Exec(ctx)
	return err
}

// Delete deletes a vulnerability by ID
func (r *VulnerabilityRepository) Delete(ctx context.Context, id int64) error {
	_, err := r.db.NewDelete().
		Model((*database.Vulnerability)(nil)).
		Where("id = ?", id).
		Exec(ctx)
	return err
}

// DeleteByWorkspace deletes all vulnerabilities in a workspace
func (r *VulnerabilityRepository) DeleteByWorkspace(ctx context.Context, workspace string) (int64, error) {
	res, err := r.db.NewDelete().
		Model((*database.Vulnerability)(nil)).
		Where("workspace = ?", workspace).
		Exec(ctx)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// ListByWorkspace lists vulnerabilities for a workspace with pagination
func (r *VulnerabilityRepository) ListByWorkspace(ctx context.Context, workspace string, page, perPage int) ([]*database.Vulnerability, int, error) {
	if page < 1 {
		page = 1
	}
	if perPage < 1 {
		perPage = 50
	}
	offset := (page - 1) * perPage

	var vulns []*database.Vulnerability
	count, err := r.db.NewSelect().
		Model(&vulns).
		Where("workspace = ?", workspace).
		Order("created_at DESC").
		Limit(perPage).
		Offset(offset).
		ScanAndCount(ctx)

	return vulns, count, err
}

// CountByWorkspace returns the count of vulnerabilities in a workspace
func (r *VulnerabilityRepository) CountByWorkspace(ctx context.Context, workspace string) (int, error) {
	return r.db.NewSelect().
		Model((*database.Vulnerability)(nil)).
		Where("workspace = ?", workspace).
		Count(ctx)
}

// Search searches vulnerabilities with multiple criteria
func (r *VulnerabilityRepository) Search(ctx context.Context, query VulnerabilityQuery) ([]*database.Vulnerability, int, error) {
	if query.Page < 1 {
		query.Page = 1
	}
	if query.PerPage < 1 {
		query.PerPage = 50
	}
	offset := (query.Page - 1) * query.PerPage

	var vulns []*database.Vulnerability
	q := r.db.NewSelect().Model(&vulns)

	if query.Workspace != "" {
		q = q.Where("workspace = ?", query.Workspace)
	}
	if query.Severity != "" {
		q = q.Where("severity = ?", query.Severity)
	}
	if query.Confidence != "" {
		q = q.Where("confidence = ?", query.Confidence)
	}
	if query.AssetType != "" {
		q = q.Where("asset_type = ?", query.AssetType)
	}
	if query.AssetValue != "" {
		q = q.Where("asset_value LIKE ?", "%"+query.AssetValue+"%")
	}
	if query.VulnTitle != "" {
		q = q.Where("vuln_title LIKE ?", "%"+query.VulnTitle+"%")
	}

	count, err := q.
		Order("created_at DESC").
		Limit(query.PerPage).
		Offset(offset).
		ScanAndCount(ctx)

	return vulns, count, err
}

// GetSeveritySummary returns a summary of vulnerabilities by severity for a workspace
func (r *VulnerabilityRepository) GetSeveritySummary(ctx context.Context, workspace string) (map[string]int, error) {
	var results []struct {
		Severity string `bun:"severity"`
		Count    int    `bun:"count"`
	}

	query := r.db.NewSelect().
		Model((*database.Vulnerability)(nil)).
		ColumnExpr("severity, COUNT(*) AS count").
		Group("severity")

	if workspace != "" {
		query = query.Where("workspace = ?", workspace)
	}

	err := query.Scan(ctx, &results)
	if err != nil {
		return nil, err
	}

	summary := make(map[string]int)
	for _, r := range results {
		summary[r.Severity] = r.Count
	}

	return summary, nil
}

// ListBySeverity lists vulnerabilities with a specific severity
func (r *VulnerabilityRepository) ListBySeverity(ctx context.Context, workspace string, severity string) ([]*database.Vulnerability, error) {
	var vulns []*database.Vulnerability
	query := r.db.NewSelect().Model(&vulns)

	if workspace != "" {
		query = query.Where("workspace = ?", workspace)
	}

	err := query.
		Where("severity = ?", severity).
		Order("created_at DESC").
		Scan(ctx)
	return vulns, err
}

// ListByAssetValue lists vulnerabilities for a specific asset value
func (r *VulnerabilityRepository) ListByAssetValue(ctx context.Context, assetValue string) ([]*database.Vulnerability, error) {
	var vulns []*database.Vulnerability
	err := r.db.NewSelect().
		Model(&vulns).
		Where("asset_value = ?", assetValue).
		Order("created_at DESC").
		Scan(ctx)
	return vulns, err
}
